import Comlink from 'comlink';
import { t as toRelativeUrl, D as DEFAULT_BASE_URL, c as removePathPrefix, e as ensurePathPrefix, d as responseTo } from './urls-4b565ba2.js';
export { a as awaitReply, g as getURLScope, i as isURLScoped, p as postMessageExpectReply, r as removeURLScope, s as setURLScope } from './urls-4b565ba2.js';

const STR = 'string';
const NUM = 'number';
const loadedRuntimes = [];
/**
 * Loads the PHP runtime with the given arguments and data dependencies.
 *
 * This function handles the entire PHP initialization pipeline. In particular, it:
 *
 * * Instantiates the Emscripten PHP module
 * * Wires it together with the data dependencies and loads them
 * * Ensures is all happens in a correct order
 * * Waits until the entire loading sequence is finished
 *
 * Basic usage:
 *
 * ```js
 *  const phpLoaderModule = await import("/php.js");
 *  const php = await startPHP(phpLoaderModule, "web");
 *  console.log(php.run(`<?php echo "Hello, world!"; `));
 *  // { stdout: ArrayBuffer containing the string "Hello, world!", stderr: [''], exitCode: 0 }
 * ```
 *
 * **The `/php.js` module:**
 *
 * In the basic usage example, `php.js` is **not** a vanilla Emscripten module. Instead,
 * it's an ESM module that wraps the regular Emscripten output and adds some
 * extra functionality. It's generated by the Dockerfile shipped with this repo.
 * Here's the API it provides:
 *
 * ```js
 * // php.wasm size in bytes:
 * export const dependenciesTotalSize = 5644199;
 *
 * // php.wasm filename:
 * export const dependencyFilename = 'php.wasm';
 *
 * // Run Emscripten's generated module:
 * export default function(jsEnv, emscriptenModuleArgs) {}
 * ```
 *
 * **PHP Filesystem:**
 *
 * Once initialized, the PHP has its own filesystem separate from the project
 * files. It's provided by [Emscripten and uses its FS library](https://emscripten.org/docs/api_reference/Filesystem-API.html).
 *
 * The API exposed to you via the PHP class is succinct and abstracts
 * await certain unintuitive parts of low-level FS interactions.
 *
 * Here's how to use it:
 *
 * ```js
 * // Recursively create a /var/www directory
 * php.mkdirTree('/var/www');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // false
 *
 * php.writeFile('/var/www/file.txt', 'Hello from the filesystem!');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // true
 *
 * console.log(php.readFile('/var/www/file.txt'));
 * // "Hello from the filesystem!
 *
 * // Delete the file:
 * php.unlink('/var/www/file.txt');
 * ```
 *
 * For more details consult the PHP class directly.
 *
 * **Data dependencies:**
 *
 * Using existing PHP packages by manually recreating them file-by-file would
 * be quite inconvenient. Fortunately, Emscripten provides a "data dependencies"
 * feature.
 *
 * Data dependencies consist of a `dependency.data` file and a `dependency.js` loader and
 * can be packaged with the [file_packager.py tool]( https://emscripten.org/docs/porting/files/packaging_files.html#packaging-using-the-file-packager-tool).
 * This project requires wrapping the Emscripten-generated `dependency.js` file in an ES
 * module as follows:
 *
 * 1. Prepend `export default function(emscriptenPHPModule) {'; `
 * 2. Prepend `export const dependencyFilename = '<DATA FILE NAME>'; `
 * 3. Prepend `export const dependenciesTotalSize = <DATA FILE SIZE>;`
 * 4. Append `}`
 *
 * Be sure to use the `--export-name="emscriptenPHPModule"` file_packager.py option.
 *
 * You want the final output to look as follows:
 *
 * ```js
 * export const dependenciesTotalSize = 5644199;
 * export const dependencyFilename = 'dependency.data';
 * export default function(emscriptenPHPModule) {
 *    // Emscripten-generated code:
 *    var Module = typeof emscriptenPHPModule !== 'undefined' ? emscriptenPHPModule : {};
 *    // ... the rest of it ...
 * }
 * ```
 *
 * Such a constructions enables loading the `dependency.js` as an ES Module using
 * `import("/dependency.js")`.
 *
 * Once it's ready, you can load PHP and your data dependencies as follows:
 *
 * ```js
 *  const [phpLoaderModule, wordPressLoaderModule] = await Promise.all([
 *    import("/php.js"),
 *    import("/wp.js")
 *  ]);
 *  const php = await startPHP(phpLoaderModule, "web", {}, [wordPressLoaderModule]);
 * ```
 *
 * @public
 * @param  phpLoaderModule         - The ESM-wrapped Emscripten module. Consult the Dockerfile for the build process.
 * @param  runtime                 - The current JavaScript environment. One of: NODE, WEB, or WEBWORKER.
 * @param  phpModuleArgs           - The Emscripten module arguments, see https://emscripten.org/docs/api_reference/module.html#affecting-execution.
 * @param  dataDependenciesModules - A list of the ESM-wrapped Emscripten data dependency modules.
 * @returns Loaded runtime id.
 */
async function loadPHPRuntime(phpLoaderModule, phpModuleArgs = {}, dataDependenciesModules = []) {
    let resolvePhpReady, resolveDepsReady;
    const depsReady = new Promise((resolve) => {
        resolveDepsReady = resolve;
    });
    const phpReady = new Promise((resolve) => {
        resolvePhpReady = resolve;
    });
    const PHPRuntime = phpLoaderModule.default(currentJsRuntime, {
        onAbort(reason) {
            console.error('WASM aborted: ');
            console.error(reason);
        },
        ENV: {},
        // Emscripten sometimes prepends a '/' to the path, which
        // breaks vite dev mode. An identity `locateFile` function
        // fixes it.
        locateFile: (path) => path,
        ...phpModuleArgs,
        noInitialRun: true,
        onRuntimeInitialized() {
            if (phpModuleArgs.onRuntimeInitialized) {
                phpModuleArgs.onRuntimeInitialized();
            }
            resolvePhpReady();
        },
        monitorRunDependencies(nbLeft) {
            if (nbLeft === 0) {
                delete PHPRuntime.monitorRunDependencies;
                resolveDepsReady();
            }
        },
    });
    for (const { default: loadDataModule } of dataDependenciesModules) {
        loadDataModule(PHPRuntime);
    }
    if (!dataDependenciesModules.length) {
        resolveDepsReady();
    }
    await depsReady;
    await phpReady;
    loadedRuntimes.push(PHPRuntime);
    return loadedRuntimes.length - 1;
}
const currentJsRuntime = (function () {
    if (typeof window !== 'undefined') {
        return 'WEB';
    }
    else if (typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope) {
        return 'WORKER';
    }
    else {
        return 'NODE';
    }
})();
/**
 * An environment-agnostic wrapper around the Emscripten PHP runtime
 * that abstracts the super low-level API and provides a more convenient
 * higher-level API.
 *
 * It exposes a minimal set of methods to run PHP scripts and to
 * interact with the PHP filesystem.
 *
 * @public
 * @see {startPHP} This class is not meant to be used directly. Use `startPHP` instead.
 */
class PHP {
    #Runtime;
    #phpIniOverrides = [];
    #webSapiInitialized = false;
    /**
     * Initializes a PHP runtime.
     *
     * @internal
     * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
     */
    constructor(PHPRuntimeId) {
        if (PHPRuntimeId !== undefined) {
            this.initializeRuntime(PHPRuntimeId);
        }
    }
    initializeRuntime(runtimeId) {
        if (this.#Runtime) {
            throw new Error('PHP runtime already initialized.');
        }
        if (!loadedRuntimes[runtimeId]) {
            throw new Error('Invalid PHP runtime id.');
        }
        this.#Runtime = loadedRuntimes[runtimeId];
    }
    setPhpIniPath(path) {
        if (this.#webSapiInitialized) {
            throw new Error('Cannot set PHP ini path after calling run().');
        }
        this.#Runtime.ccall('wasm_set_phpini_path', null, ['string'], [path]);
    }
    setPhpIniEntry(key, value) {
        if (this.#webSapiInitialized) {
            throw new Error('Cannot set PHP ini entries after calling run().');
        }
        this.#phpIniOverrides.push([key, value]);
    }
    run(request = {}) {
        if (!this.#webSapiInitialized) {
            this.#initWebRuntime();
            this.#webSapiInitialized = true;
        }
        this.#setScriptPath(request.scriptPath || '');
        this.#setRelativeRequestUri(request.relativeUri || '');
        this.#setRequestMethod(request.method || 'GET');
        const { host, ...headers } = {
            host: 'example.com:443',
            ...normalizeHeaders(request.headers || {}),
        };
        this.#setRequestHostAndProtocol(host, request.protocol || 'http');
        this.#setRequestHeaders(headers);
        if (request.body) {
            this.#setRequestBody(request.body);
        }
        if (request.fileInfos) {
            for (const file of request.fileInfos) {
                this.#addUploadedFile(file);
            }
        }
        if (request.code) {
            this.#setPHPCode(' ?>' + request.code);
        }
        return this.#handleRequest();
    }
    #initWebRuntime() {
        if (this.#phpIniOverrides.length > 0) {
            const overridesAsIni = this.#phpIniOverrides
                .map(([key, value]) => `${key}=${value}`)
                .join('\n');
            this.#Runtime.ccall('wasm_set_phpini_entries', null, [STR], [overridesAsIni]);
        }
        this.#Runtime.ccall('php_wasm_init', null, [], []);
    }
    cli(argv) {
        for (const arg of argv) {
            this.#Runtime.ccall('wasm_add_cli_arg', null, [STR], [arg]);
        }
        return this.#Runtime.ccall('run_cli', null, [], [], { async: true });
    }
    #getResponseHeaders() {
        const headersFilePath = '/tmp/headers.json';
        if (!this.fileExists(headersFilePath)) {
            throw new Error('SAPI Error: Could not find response headers file.');
        }
        const headersData = JSON.parse(this.readFileAsText(headersFilePath));
        const headers = {};
        for (const line of headersData.headers) {
            if (!line.includes(': ')) {
                continue;
            }
            const colonIndex = line.indexOf(': ');
            const headerName = line.substring(0, colonIndex).toLowerCase();
            const headerValue = line.substring(colonIndex + 2);
            if (!(headerName in headers)) {
                headers[headerName] = [];
            }
            headers[headerName].push(headerValue);
        }
        return {
            headers,
            httpStatusCode: headersData.status,
        };
    }
    #setRelativeRequestUri(uri) {
        this.#Runtime.ccall('wasm_set_request_uri', null, [STR], [uri]);
        if (uri.includes('?')) {
            const queryString = uri.substring(uri.indexOf('?') + 1);
            this.#Runtime.ccall('wasm_set_query_string', null, [STR], [queryString]);
        }
    }
    #setRequestHostAndProtocol(host, protocol) {
        this.#Runtime.ccall('wasm_set_request_host', null, [STR], [host]);
        let port;
        try {
            port = parseInt(new URL(host).port, 10);
        }
        catch (e) { }
        if (!port || isNaN(port) || port === 80) {
            port = protocol === 'https' ? 443 : 80;
        }
        this.#Runtime.ccall('wasm_set_request_port', null, [NUM], [port]);
        if (protocol === 'https' || (!protocol && port === 443)) {
            this.addServerGlobalEntry('HTTPS', 'on');
        }
    }
    #setRequestMethod(method) {
        this.#Runtime.ccall('wasm_set_request_method', null, [STR], [method]);
    }
    setSkipShebang(shouldSkip) {
        this.#Runtime.ccall('wasm_set_skip_shebang', null, [NUM], [shouldSkip ? 1 : 0]);
    }
    #setRequestHeaders(headers) {
        if (headers.cookie) {
            this.#Runtime.ccall('wasm_set_cookies', null, [STR], [headers.cookie]);
        }
        if (headers['content-type']) {
            this.#Runtime.ccall('wasm_set_content_type', null, [STR], [headers['content-type']]);
        }
        if (headers['content-length']) {
            this.#Runtime.ccall('wasm_set_content_length', null, [NUM], [parseInt(headers['content-length'], 10)]);
        }
        for (const name in headers) {
            this.addServerGlobalEntry(`HTTP_${name.toUpperCase().replace(/-/g, '_')}`, headers[name]);
        }
    }
    #setRequestBody(body) {
        this.#Runtime.ccall('wasm_set_request_body', null, [STR], [body]);
        this.#Runtime.ccall('wasm_set_content_length', null, [NUM], [body.length]);
    }
    #setScriptPath(path) {
        this.#Runtime.ccall('wasm_set_path_translated', null, [STR], [path]);
    }
    addServerGlobalEntry(key, value) {
        this.#Runtime.ccall('wasm_add_SERVER_entry', null, [STR, STR], [key, value]);
    }
    /**
     * Adds file information to $_FILES superglobal in PHP.
     *
     * In particular:
     * * Creates the file data in the filesystem
     * * Registers the file details in PHP
     *
     * @param  fileInfo - File details
     */
    #addUploadedFile(fileInfo) {
        const { key, name, type, data } = fileInfo;
        const tmpPath = `/tmp/${Math.random().toFixed(20)}`;
        this.writeFile(tmpPath, data);
        const error = 0;
        this.#Runtime.ccall('wasm_add_uploaded_file', null, [STR, STR, STR, STR, NUM, NUM], [key, name, type, tmpPath, error, data.byteLength]);
    }
    #setPHPCode(code) {
        this.#Runtime.ccall('wasm_set_php_code', null, [STR], [code]);
    }
    #handleRequest() {
        const exitCode = this.#Runtime.ccall('wasm_sapi_handle_request', NUM, [], []);
        return {
            exitCode,
            body: this.readFileAsBuffer('/tmp/stdout'),
            errors: this.readFileAsText('/tmp/stderr'),
            ...this.#getResponseHeaders(),
        };
    }
    mkdirTree(path) {
        this.#Runtime.FS.mkdirTree(path);
    }
    readFileAsText(path) {
        return new TextDecoder().decode(this.readFileAsBuffer(path));
    }
    readFileAsBuffer(path) {
        return this.#Runtime.FS.readFile(path);
    }
    writeFile(path, data) {
        this.#Runtime.FS.writeFile(path, data);
    }
    unlink(path) {
        this.#Runtime.FS.unlink(path);
    }
    listFiles(path) {
        if (!this.fileExists(path)) {
            return [];
        }
        try {
            return this.#Runtime.FS.readdir(path).filter((name) => name !== '.' && name !== '..');
        }
        catch (e) {
            console.error(e, { path });
            return [];
        }
    }
    isDir(path) {
        if (!this.fileExists(path)) {
            return false;
        }
        return this.#Runtime.FS.isDir(this.#Runtime.FS.lookupPath(path).node.mode);
    }
    fileExists(path) {
        try {
            this.#Runtime.FS.lookupPath(path);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    mount(settings, path) {
        this.#Runtime.FS.mount(this.#Runtime.FS.filesystems.NODEFS, settings, path);
    }
}
function normalizeHeaders(headers) {
    const normalized = {};
    for (const key in headers) {
        normalized[key.toLowerCase()] = headers[key];
    }
    return normalized;
}

function consumeAPI(remote) {
    setupTransferHandlers();
    const endpoint = remote instanceof Worker ? remote : Comlink.windowEndpoint(remote);
    return Comlink.wrap(endpoint);
}
function exposeAPI(apiMethods, pipedApi) {
    setupTransferHandlers();
    let setReady;
    const ready = new Promise((resolve) => {
        setReady = resolve;
    });
    const methods = proxyClone(apiMethods);
    const exposedApi = new Proxy(methods, {
        get: (target, prop) => {
            if (prop === 'isReady') {
                return () => ready;
            }
            if (prop in target) {
                return target[prop];
            }
            return pipedApi?.[prop];
        },
    });
    Comlink.expose(exposedApi, typeof window !== 'undefined'
        ? Comlink.windowEndpoint(self.parent)
        : undefined);
    return [
        setReady,
        exposedApi,
    ];
}
function setupTransferHandlers() {
    Comlink.transferHandlers.set('EVENT', {
        canHandle: (obj) => obj instanceof CustomEvent,
        serialize: (ev) => {
            return [
                {
                    detail: ev.detail,
                },
                [],
            ];
        },
        deserialize: (obj) => obj,
    });
    Comlink.transferHandlers.set('FUNCTION', {
        canHandle: (obj) => typeof obj === 'function',
        serialize(obj) {
            console.debug('[Comlink][Performance] Proxying a function');
            const { port1, port2 } = new MessageChannel();
            Comlink.expose(obj, port1);
            return [port2, [port2]];
        },
        deserialize(port) {
            port.start();
            return Comlink.wrap(port);
        },
    });
}
function proxyClone(object) {
    return new Proxy(object, {
        get(target, prop) {
            switch (typeof target[prop]) {
                case 'function':
                    return (...args) => target[prop](...args);
                case 'object':
                    if (target[prop] === null) {
                        return target[prop];
                    }
                    return proxyClone(target[prop]);
                case 'undefined':
                case 'number':
                case 'string':
                    return target[prop];
                default:
                    return Comlink.proxy(target[prop]);
            }
        },
    });
}

/**
 * A fake PHP server that handles HTTP requests but does not
 * bind to any port.
 *
 * @public
 * @example
 * ```js
 * import { createPHP, PHPServer } from 'php-wasm';
 *
 * const PHPLoaderModule = await import('/php.js');
 * const php = await createPHP(PHPLoaderModule);
 *
 * // Create a file to serve:
 * php.mkdirTree('/www');
 * php.writeFile('/www/index.php', '<?php echo "Hi from PHP!"; ');
 *
 * // Create a server instance:
 * const server = new PHPServer(php, {
 *     // PHP FS path to serve the files from:
 *     documentRoot: '/www',
 *
 *     // Used to populate $_SERVER['SERVER_NAME'] etc.:
 *     absoluteUrl: 'http://127.0.0.1'
 * });
 *
 * console.log(
 *    server.request({ path: '/index.php' }).body
 * );
 * // Output: "Hi from PHP!"
 * ```
 */
class PHPServer {
    #DOCROOT;
    #PROTOCOL;
    #HOSTNAME;
    #PORT;
    #HOST;
    #PATHNAME;
    #ABSOLUTE_URL;
    /**
     * The PHP instance
     */
    php;
    #isStaticFilePath;
    /**
     * @param  php    - The PHP instance.
     * @param  config - Server configuration.
     */
    constructor(php, config = {}) {
        const { documentRoot = '/www/', absoluteUrl = location.origin, isStaticFilePath = () => false, } = config;
        this.php = php;
        this.#DOCROOT = documentRoot;
        this.#isStaticFilePath = isStaticFilePath;
        const url = new URL(absoluteUrl);
        this.#HOSTNAME = url.hostname;
        this.#PORT = url.port
            ? Number(url.port)
            : url.protocol === 'https:'
                ? 443
                : 80;
        this.#PROTOCOL = (url.protocol || '').replace(':', '');
        const isNonStandardPort = this.#PORT !== 443 && this.#PORT !== 80;
        this.#HOST = [
            this.#HOSTNAME,
            isNonStandardPort ? `:${this.#PORT}` : '',
        ].join('');
        this.#PATHNAME = url.pathname.replace(/\/+$/, '');
        this.#ABSOLUTE_URL = [
            `${this.#PROTOCOL}://`,
            this.#HOST,
            this.#PATHNAME,
        ].join('');
    }
    /**
     * Converts a path to an absolute URL based at the PHPServer
     * root.
     *
     * @param  path The server path to convert to an absolute URL.
     * @returns The absolute URL.
     */
    pathToInternalUrl(path) {
        return `${this.absoluteUrl}${path}`;
    }
    /**
     * Converts an absolute URL based at the PHPServer to a relative path
     * without the server pathname and scope.
     *
     * @param  internalUrl An absolute URL based at the PHPServer root.
     * @returns The relative path.
     */
    internalUrlToPath(internalUrl) {
        const url = new URL(internalUrl);
        if (url.pathname.startsWith(this.#PATHNAME)) {
            url.pathname = url.pathname.slice(this.#PATHNAME.length);
        }
        return toRelativeUrl(url);
    }
    /**
     * The absolute URL of this PHPServer instance.
     */
    get absoluteUrl() {
        return this.#ABSOLUTE_URL;
    }
    /**
     * Serves the request – either by serving a static file, or by
     * dispatching it to the PHP runtime.
     *
     * @param  request - The request.
     * @returns The response.
     */
    async request(request) {
        let requestedUrl;
        if (request.relativeUrl !== undefined) {
            requestedUrl = new URL(request.relativeUrl, DEFAULT_BASE_URL);
        }
        else {
            requestedUrl = new URL(request.absoluteUrl);
        }
        const normalizedRelativeUrl = removePathPrefix(requestedUrl.pathname, this.#PATHNAME);
        if (this.#isStaticFilePath(normalizedRelativeUrl)) {
            return this.#serveStaticFile(normalizedRelativeUrl);
        }
        return await this.#dispatchToPHP(request, requestedUrl);
    }
    /**
     * Serves a static file from the PHP filesystem.
     *
     * @param  path - The requested static file path.
     * @returns The response.
     */
    #serveStaticFile(path) {
        const fsPath = `${this.#DOCROOT}${path}`;
        if (!this.php.fileExists(fsPath)) {
            return {
                body: new TextEncoder().encode('404 File not found'),
                headers: {},
                httpStatusCode: 404,
                exitCode: 0,
                errors: '',
            };
        }
        const arrayBuffer = this.php.readFileAsBuffer(fsPath);
        return {
            body: arrayBuffer,
            headers: {
                'content-length': `${arrayBuffer.byteLength}`,
                // @TODO: Infer the content-type from the arrayBuffer instead of the file path.
                //        The code below won't return the correct mime-type if the extension
                //        was tampered with.
                'content-type': inferMimeType(fsPath),
                'accept-ranges': 'bytes',
                'cache-control': 'public, max-age=0',
            },
            httpStatusCode: 200,
            exitCode: 0,
            errors: '',
        };
    }
    /**
     * Runs the requested PHP file with all the request and $_SERVER
     * superglobals populated.
     *
     * @param  request - The request.
     * @returns The response.
     */
    async #dispatchToPHP(request, requestedUrl) {
        this.php.addServerGlobalEntry('DOCUMENT_ROOT', this.#DOCROOT);
        this.php.addServerGlobalEntry('HTTPS', this.#ABSOLUTE_URL.startsWith('https://') ? 'on' : '');
        let preferredMethod = 'GET';
        const fileInfos = [];
        if (request.files) {
            preferredMethod = 'POST';
            for (const key in request.files) {
                const file = request.files[key];
                fileInfos.push({
                    key,
                    name: file.name,
                    type: file.type,
                    data: new Uint8Array(await file.arrayBuffer()),
                });
            }
        }
        const defaultHeaders = {
            host: this.#HOST,
        };
        let body;
        if (request.formData !== undefined) {
            preferredMethod = 'POST';
            defaultHeaders['content-type'] = 'application/x-www-form-urlencoded';
            body = new URLSearchParams(request.formData).toString();
        }
        else {
            body = request.body;
        }
        return this.php.run({
            relativeUri: ensurePathPrefix(toRelativeUrl(requestedUrl), this.#PATHNAME),
            protocol: this.#PROTOCOL,
            method: request.method || preferredMethod,
            body,
            fileInfos,
            scriptPath: this.#resolvePHPFilePath(requestedUrl.pathname),
            headers: {
                ...defaultHeaders,
                ...(request.headers || {})
            },
        });
    }
    /**
     * Resolve the requested path to the filesystem path of the requested PHP file.
     *
     * Fall back to index.php as if there was a url rewriting rule in place.
     *
     * @param  requestedPath - The requested pathname.
     * @returns The resolved filesystem path.
     */
    #resolvePHPFilePath(requestedPath) {
        let filePath = removePathPrefix(requestedPath, this.#PATHNAME);
        // If the path mentions a .php extension, that's our file's path.
        if (filePath.includes('.php')) {
            filePath = filePath.split('.php')[0] + '.php';
        }
        else {
            // Otherwise, let's assume the file is $request_path/index.php
            if (!filePath.endsWith('/')) {
                filePath += '/';
            }
            if (!filePath.endsWith('index.php')) {
                filePath += 'index.php';
            }
        }
        const resolvedFsPath = `${this.#DOCROOT}${filePath}`;
        if (this.php.fileExists(resolvedFsPath)) {
            return resolvedFsPath;
        }
        return `${this.#DOCROOT}/index.php`;
    }
}
/**
 * Naively infer a file mime type from its path.
 *
 * @todo Infer the mime type based on the file contents.
 *       A naive function like this one can be inaccurate
 *       and potentially have negative security consequences.
 *
 * @param  path - The file path
 * @returns The inferred mime type.
 */
function inferMimeType(path) {
    const extension = path.split('.').pop();
    switch (extension) {
        case 'css':
            return 'text/css';
        case 'js':
            return 'application/javascript';
        case 'png':
            return 'image/png';
        case 'jpg':
        case 'jpeg':
            return 'image/jpeg';
        case 'gif':
            return 'image/gif';
        case 'svg':
            return 'image/svg+xml';
        case 'woff':
            return 'font/woff';
        case 'woff2':
            return 'font/woff2';
        case 'ttf':
            return 'font/ttf';
        case 'otf':
            return 'font/otf';
        case 'eot':
            return 'font/eot';
        case 'ico':
            return 'image/x-icon';
        case 'html':
            return 'text/html';
        case 'json':
            return 'application/json';
        case 'xml':
            return 'application/xml';
        case 'txt':
        case 'md':
            return 'text/plain';
        default:
            return 'application-octet-stream';
    }
}

/**
 * A fake web browser that handles PHPServer's cookies and redirects
 * internally without exposing them to the consumer.
 *
 * @public
 */
class PHPBrowser {
    #cookies;
    #config;
    server;
    /**
     * @param  server - The PHP server to browse.
     * @param  config - The browser configuration.
     */
    constructor(server, config = {}) {
        this.server = server;
        this.#cookies = {};
        this.#config = {
            handleRedirects: false,
            maxRedirects: 4,
            ...config,
        };
    }
    async request(request, redirects = 0) {
        const response = await this.server.request({
            ...request,
            headers: {
                ...request.headers,
                cookie: this.#serializeCookies(),
            },
        });
        if (response.headers['set-cookie']) {
            this.#setCookies(response.headers['set-cookie']);
        }
        if (this.#config.handleRedirects &&
            response.headers.location &&
            redirects < this.#config.maxRedirects) {
            const redirectUrl = new URL(response.headers.location[0], this.server.absoluteUrl);
            return this.request({
                absoluteUrl: redirectUrl.toString(),
                method: 'GET',
                headers: {},
            }, redirects + 1);
        }
        return response;
    }
    #setCookies(cookies) {
        for (const cookie of cookies) {
            try {
                if (!cookie.includes('=')) {
                    continue;
                }
                const equalsIndex = cookie.indexOf('=');
                const name = cookie.substring(0, equalsIndex);
                const value = cookie.substring(equalsIndex + 1).split(';')[0];
                this.#cookies[name] = value;
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    #serializeCookies() {
        const cookiesArray = [];
        for (const name in this.#cookies) {
            cookiesArray.push(`${name}=${this.#cookies[name]}`);
        }
        return cookiesArray.join('; ');
    }
}

async function getPHPLoaderModule(version = '8.2') {
    switch (version) {
        case '8.2':
            // @ts-ignore
            return await import('./php-8.2-e5f6cd52.js');
        case '8.1':
            // @ts-ignore
            return await import('./php-8.1-50b6e6cb.js');
        case '8.0':
            // @ts-ignore
            return await import('./php-8.0-139a7929.js');
        case '7.4':
            // @ts-ignore
            return await import('./php-7.4-c48ed242.js');
        case '7.3':
            // @ts-ignore
            return await import('./php-7.3-1cad53d4.js');
        case '7.2':
            // @ts-ignore
            return await import('./php-7.2-bda06208.js');
        case '7.1':
            // @ts-ignore
            return await import('./php-7.1-f1d81fdb.js');
        case '7.0':
            // @ts-ignore
            return await import('./php-7.0-109607a3.js');
        case '5.6':
            // @ts-ignore
            return await import('./php-5.6-8f7768c7.js');
    }
    throw new Error(`Unsupported PHP version ${version}`);
}
function parseWorkerStartupOptions() {
    // Read the query string startup options
    if (typeof self?.location?.href !== 'undefined') {
        // Web
        const startupOptions = {};
        const params = new URL(self.location.href).searchParams;
        params.forEach((value, key) => {
            startupOptions[key] = value;
        });
        return startupOptions;
    }
    else {
        // Node.js
        return JSON.parse(process.env.WORKER_OPTIONS || '{}');
    }
}

const recommendedWorkerBackend = (function () {
    // Firefox doesn't support module workers with dynamic imports,
    // let's fall back to iframe workers.
    // See https://github.com/mdn/content/issues/24402
    const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    if (isFirefox) {
        return 'iframe';
    }
    else {
        return 'webworker';
    }
})();
/**
 * Spawns a new Worker Thread.
 *
 * @param  workerUrl The absolute URL of the worker script.
 * @param  workerBackend     The Worker Thread backend to use. Either 'webworker' or 'iframe'.
 * @param  config
 * @returns The spawned Worker Thread.
 */
function spawnPHPWorkerThread(workerUrl, workerBackend = 'webworker', startupOptions = {}) {
    workerUrl = addQueryParams(workerUrl, startupOptions);
    if (workerBackend === 'webworker') {
        return new Worker(workerUrl, { type: 'module' });
    }
    else if (workerBackend === 'iframe') {
        return createIframe(workerUrl).contentWindow;
    }
    else {
        throw new Error(`Unknown backendName: ${workerBackend}`);
    }
}
function addQueryParams(url, searchParams) {
    if (!Object.entries(searchParams).length) {
        return url;
    }
    const urlWithOptions = new URL(url);
    for (const [key, value] of Object.entries(searchParams)) {
        urlWithOptions.searchParams.set(key, value);
    }
    return urlWithOptions.toString();
}
function createIframe(workerDocumentURL) {
    const iframe = document.createElement('iframe');
    iframe.src = workerDocumentURL;
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    return iframe;
}

/**
 * Run this in the main application to register the service worker or
 * reload the registered worker if the app expects a different version
 * than the currently registered one.
 *
 * @param {string} scriptUrl       The URL of the service worker script.
 * @param {string} expectedVersion The expected version of the service worker script. If
 *                                 mismatched with the actual version, the service worker
 *                                 will be re-registered.
 */
async function registerServiceWorker(phpApi, scope, scriptUrl, expectedVersion) {
    const sw = navigator.serviceWorker;
    if (!sw) {
        throw new Error('Service workers are not supported in this browser.');
    }
    const registrations = await sw.getRegistrations();
    if (registrations.length > 0) {
        const actualVersion = await getRegisteredServiceWorkerVersion();
        if (expectedVersion !== actualVersion) {
            console.debug(`[window] Reloading the currently registered Service Worker ` +
                `(expected version: ${expectedVersion}, registered version: ${actualVersion})`);
            for (const registration of registrations) {
                await registration.update();
                const waitingWorker = registration.waiting || registration.installing;
                if (waitingWorker) {
                    if (actualVersion !== null) {
                        // If the worker exposes a version, it supports
                        // a "skip-waiting" message – let's force it to
                        // skip waiting.
                        waitingWorker.postMessage('skip-waiting');
                    }
                    else {
                        // If the version is not exposed, we can't force
                        // the worker to skip waiting – let's unregister
                        // and reload the page.
                        await registration.unregister();
                        window.location.reload();
                    }
                }
            }
        }
    }
    else {
        console.debug(`[window] Creating a Service Worker registration (version: ${expectedVersion})`);
        await sw.register(scriptUrl, {
            type: 'module',
        });
    }
    // Proxy the service worker messages to the worker thread:
    navigator.serviceWorker.addEventListener('message', async function onMessage(event) {
        console.debug('Message from ServiceWorker', event);
        /**
         * Ignore events meant for other PHP instances to
         * avoid handling the same event twice.
         *
         * This is important because the service worker posts the
         * same message to all application instances across all browser tabs.
         */
        if (scope && event.data.scope !== scope) {
            return;
        }
        const args = event.data.args || [];
        const result = await phpApi[event.data.method](...args);
        event.source.postMessage(responseTo(event.data.requestId, result));
    });
    sw.startMessages();
}
async function getRegisteredServiceWorkerVersion() {
    try {
        const response = await fetch('/version');
        const data = await response.json();
        return data.version;
    }
    catch (e) {
        return null;
    }
}

/*
 * An approximate total file size to use when the actual
 * total number of bytes is missing.
 *
 * This may happen when the files are compressed before transmission
 * and no content-length header is being sent.
 *
 * The approximation isn't accurate, but it's better than nothing.
 * It's not about being exact but about giving the user a rough sense
 * of #progress.
 */
const FALLBACK_FILE_SIZE = 5 * 1024 * 1024;
/**
 * Monitors the download #progress of Emscripten modules
 *
 * Usage:
 * ```js
 *   const downloadMonitor = new EmscriptenDownloadMonitor();
 * 	 const php = await startPHP(
 *       phpLoaderModule,
 *       'web',
 *       downloadMonitor.phpArgs
 *   );
 *   downloadMonitor.addEventListener('#progress', (e) => {
 *     console.log( e.detail.#progress);
 *   })
 * ```
 */
class EmscriptenDownloadMonitor extends EventTarget {
    #assetsSizes = {};
    #progress = {};
    constructor(modules = []) {
        super();
        this.setModules(modules);
        this.#monitorWebAssemblyStreaming();
    }
    getEmscriptenArgs() {
        return {
            dataFileDownloads: this.#createDataFileDownloadsProxy(),
        };
    }
    setModules(modules) {
        this.#assetsSizes = modules.reduce((acc, module) => {
            if (module.dependenciesTotalSize > 0) {
                const url = new URL(module.dependencyFilename, 'http://example.com').pathname;
                const filename = url.split('/').pop();
                acc[filename] = Math.max(filename in acc ? acc[filename] : 0, module.dependenciesTotalSize);
            }
            return acc;
        }, {});
        this.#progress = Object.fromEntries(Object.entries(this.#assetsSizes).map(([name]) => [name, 0]));
    }
    /**
     * Replaces the default WebAssembly.instantiateStreaming with a version
     * that monitors the download #progress.
     */
    #monitorWebAssemblyStreaming() {
        const instantiateStreaming = WebAssembly.instantiateStreaming;
        WebAssembly.instantiateStreaming = async (responseOrPromise, ...args) => {
            const response = await responseOrPromise;
            const file = response.url.substring(new URL(response.url).origin.length + 1);
            const reportingResponse = cloneResponseMonitorProgress(response, ({ detail: { loaded, total } }) => this.#notify(file, loaded, total));
            return instantiateStreaming(reportingResponse, ...args);
        };
    }
    /**
     * Creates a `dataFileDownloads` Proxy object that can be passed
     * to `startPHP` to monitor the download #progress of the data
     * dependencies.
     */
    #createDataFileDownloadsProxy() {
        const self = this;
        const dataFileDownloads = {};
        // Monitor assignments like dataFileDownloads[file] = #progress
        return new Proxy(dataFileDownloads, {
            set(obj, file, progress) {
                self.#notify(file, progress.loaded, progress.total);
                // Monitor assignments like dataFileDownloads[file].total += delta
                obj[file] = new Proxy(JSON.parse(JSON.stringify(progress)), {
                    set(nestedObj, prop, value) {
                        nestedObj[prop] = value;
                        self.#notify(file, nestedObj.loaded, nestedObj.total);
                        return true;
                    },
                });
                return true;
            },
        });
    }
    /**
     * Notifies about the download #progress of a file.
     *
     * @param  file   The file name.
     * @param  loaded The number of bytes of that file loaded so far.
     * @param  fileSize  The total number of bytes in the loaded file.
     */
    #notify(file, loaded, fileSize) {
        const fileName = new URL(file, DEFAULT_BASE_URL).pathname
            .split('/')
            .pop();
        if (!fileSize) {
            fileSize = this.#assetsSizes[fileName];
        }
        if (!(fileName in this.#progress)) {
            console.warn(`Registered a download #progress of an unregistered file "${fileName}". ` +
                `This may cause a sudden **decrease** in the #progress percentage as the ` +
                `total number of bytes increases during the download.`);
        }
        this.#progress[file] = loaded;
        this.dispatchEvent(new CustomEvent('progress', {
            detail: {
                loaded: sumValues(this.#progress),
                total: sumValues(this.#assetsSizes),
            },
        }));
    }
}
function sumValues(obj) {
    return Object.values(obj).reduce((total, value) => total + value, 0);
}
/**
 * Clones a fetch Response object and returns a version
 * that calls the `onProgress` callback as the #progress
 * changes.
 *
 * @param  response   The fetch Response object to clone.
 * @param  onProgress The callback to call when the download #progress changes.
 * @returns The cloned response
 */
function cloneResponseMonitorProgress(response, onProgress) {
    const contentLength = response.headers.get('content-length') || '';
    const total = parseInt(contentLength, 10) || FALLBACK_FILE_SIZE;
    function notify(loaded, total) {
        onProgress(new CustomEvent('progress', {
            detail: {
                loaded,
                total,
            }
        }));
    }
    return new Response(new ReadableStream({
        async start(controller) {
            if (!response.body) {
                controller.close();
                return;
            }
            const reader = response.body.getReader();
            let loaded = 0;
            for (;;) {
                try {
                    const { done, value } = await reader.read();
                    if (value) {
                        loaded += value.byteLength;
                    }
                    if (done) {
                        notify(loaded, loaded);
                        controller.close();
                        break;
                    }
                    else {
                        notify(loaded, total);
                        controller.enqueue(value);
                    }
                }
                catch (e) {
                    console.error({ e });
                    controller.error(e);
                    break;
                }
            }
        },
    }), {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers,
    });
}

class ProgressObserver extends EventTarget {
    #observedProgresses = {};
    #lastObserverId = 0;
    progress = 0;
    mode = 'REAL_TIME';
    caption = "";
    partialObserver(progressBudget, caption = '') {
        const id = ++this.#lastObserverId;
        this.#observedProgresses[id] = 0;
        return (progress) => {
            const { loaded, total } = progress?.detail || {};
            this.#observedProgresses[id] = (loaded / total) * progressBudget;
            this.#onProgress(this.totalProgress, 'REAL_TIME', caption);
        };
    }
    slowlyIncrementBy(progress) {
        const id = ++this.#lastObserverId;
        this.#observedProgresses[id] = progress;
        this.#onProgress(this.totalProgress, 'SLOWLY_INCREMENT');
    }
    get totalProgress() {
        return Object.values(this.#observedProgresses).reduce((total, progress) => total + progress, 0);
    }
    #onProgress(progress, mode, caption) {
        this.dispatchEvent(new CustomEvent('progress', {
            detail: {
                progress,
                mode,
                caption,
            },
        }));
    }
}

class PHPPublicAPI {
    #php;
    #phpServer;
    #phpBrowser;
    #monitor;
    absoluteUrl;
    constructor(browser, monitor) {
        this.#phpBrowser = browser;
        this.#phpServer = browser.server;
        this.#php = browser.server.php;
        this.absoluteUrl = this.#phpServer.absoluteUrl;
        this.#monitor = monitor;
    }
    pathToInternalUrl(path) {
        return this.#phpServer.pathToInternalUrl(path);
    }
    internalUrlToPath(internalUrl) {
        return this.#phpServer.internalUrlToPath(internalUrl);
    }
    onDownloadProgress(callback) {
        this.#monitor?.addEventListener('progress', callback);
    }
    request(request, redirects) {
        return this.#phpBrowser.request(request, redirects);
    }
    async run(request) {
        return this.#php.run(request);
    }
    setPhpIniPath(path) {
        return this.#php.setPhpIniPath(path);
    }
    setPhpIniEntry(key, value) {
        this.#php.setPhpIniEntry(key, value);
    }
    mkdirTree(path) {
        this.#php.mkdirTree(path);
    }
    async readFileAsText(path) {
        return this.#php.readFileAsText(path);
    }
    async readFileAsBuffer(path) {
        return this.#php.readFileAsBuffer(path);
    }
    writeFile(path, data) {
        this.#php.writeFile(path, data);
    }
    unlink(path) {
        this.#php.unlink(path);
    }
    async listFiles(path) {
        return this.#php.listFiles(path);
    }
    async isDir(path) {
        return this.#php.isDir(path);
    }
    async fileExists(path) {
        return this.#php.fileExists(path);
    }
}

export { EmscriptenDownloadMonitor, PHP, PHPBrowser, PHPPublicAPI, PHPServer, ProgressObserver, cloneResponseMonitorProgress, consumeAPI, exposeAPI, getPHPLoaderModule, loadPHPRuntime, parseWorkerStartupOptions, recommendedWorkerBackend, registerServiceWorker, responseTo, spawnPHPWorkerThread, toRelativeUrl };
