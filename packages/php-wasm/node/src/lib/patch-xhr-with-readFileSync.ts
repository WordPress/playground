import { readFileSync } from 'node:fs';

/**
 * Replaces the global XMLHttpRequest with a custom shim.
 * The shim reads the WordPress data modules from the disk
 * instead of trying to load them over the network.
 *
 * Why?
 *
 * Emscripten autogenerated data modules use XMLHttpRequest to
 * load the .data files. However, in Node.js, the data modules
 * are stored on the disk and trying to load them with a network
 * call will fail.
 *
 * In theory, Emscripten provides the getPreloadedPackage() option
 * specifically to replace the default XHR loading mechanism and
 * we could lean on it instead. However, that option is affected
 * by a bug. If it's provided, the module loading sequence never
 * resolves. Here's an example of that behavior:
 *
 * ```ts
 * emscriptenOptions = {
 *     getPreloadedPackage(path: string) {
 *	       return readFileSync(path);
 *	   }
 * }
 * // This will never resolve:
 * await loadPHPRuntime(
 *     phpLoaderModule,
 *     emscriptenOptions,
 *     dataModules
 * );
 * ```
 *
 * If replacing the global XMLHttpRequest in Node.js will ever become
 * a problem, let's look into patching the bug in the getPreloadedPackage()
 * instead. This could happen either in Emscripten or in our WordPress
 * bundler.
 */
export function patchXHRClassToReadDataFromFilesystem() {
	// @ts-ignore
	globalThis.XMLHttpRequest = class XMLHttpRequest {
		// Methods and functions that are used by Emscripten:
		readyState = 4;
		status = 200;
		url = '';
		response?: ArrayBuffer;
		// The Emscripten loader replaces these onload and onerror functions
		// with a custom callback:
		onload() {}
		// eslint-disable-next-line
		onerror(e: any) {}
		open(_: string, url: string) {
			this.url = url;
		}
		async send() {
			let url = this.url;
			try {
				// A few security checks to make sure this code path is not exploited to
				// load arbitrary files from the filesystem.
				if (!url.endsWith('.data')) {
					throw new Error(
						`Invalid data dependency URL "${url}" – the file extension must be ".data".`
					);
				}
				if (!url.startsWith('/@fs/')) {
					throw new Error(
						`Invalid data dependency format "${url}" – the URL is expected to start with /@fs/.`
					);
				}
				url = url.replace(/^\/@fs/, '');

				// The path may still point to an arbitrary file at this point. Let's be super
				// extra careful, and only accept filenames that seem to be WordPress data
				// modules. This technically introduces coupling between the generic @php-wasm/node
				// module and the @wp-playground/wordPress module, but that's a fair price to
				// pay for the added security. If this ever becomes a problem, let's find
				// a way to leverage the Emscripten's getPreloadedPackage() option.
				if (!url.match(/\/wp-[^/']+\.data$/)) {
					throw new Error(
						`Invalid data dependency URL "${url}" – it does not seem to be a WordPress data module.`
					);
				}

				// Oki, now we're mostly confident this is a legit attempt to load a data
				// dependency. Let's load it!
				const wpData = readFileSync(url);
				// Response needs to be a Uint8Array, not a Buffer.
				this.response = wpData.buffer.slice(
					wpData.byteOffset,
					wpData.byteOffset + wpData.byteLength
				);
				this.onload();
			} catch (e) {
				this.onerror(e);
			}
		}
		// A bunch of stubs to make this shim more resilient:
		setRequestHeader() {}
		getResponseHeader() {}
		getAllResponseHeaders() {}
		abort() {}
		addEventListener() {}
		removeEventListener() {}
		dispatchEvent() {}
	};
}
