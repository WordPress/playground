const STR = 'string';
const NUM = 'number';

export type JavascriptRuntime = 'NODE' | 'WEB' | 'WEBWORKER';

/**
 * Initializes the PHP runtime with the given arguments and data dependencies.
 *
 * This function handles the entire PHP initialization pipeline. In particular, it:
 *
 * * Instantiates the Emscripten PHP module
 * * Wires it together with the data dependencies and loads them
 * * Ensures is all happens in a correct order
 * * Waits until the entire loading sequence is finished
 *
 * Basic usage:
 *
 * ```js
 *  const phpLoaderModule = await import("/php.js");
 *  const php = await startPHP(phpLoaderModule, "web");
 *  console.log(php.run(`<?php echo "Hello, world!"; `));
 *  // { stdout: ArrayBuffer containing the string "Hello, world!", stderr: [''], exitCode: 0 }
 * ```
 *
 * **The `/php.js` module:**
 *
 * In the basic usage example, `php.js` is **not** a vanilla Emscripten module. Instead,
 * it's an ESM module that wraps the regular Emscripten output and adds some
 * extra functionality. It's generated by the Dockerfile shipped with this repo.
 * Here's the API it provides:
 *
 * ```js
 * // php.wasm size in bytes:
 * export const dependenciesTotalSize = 5644199;
 *
 * // php.wasm filename:
 * export const dependencyFilename = 'php.wasm';
 *
 * // Run Emscripten's generated module:
 * export default function(jsEnv, emscriptenModuleArgs) {}
 * ```
 *
 * **PHP Filesystem:**
 *
 * Once initialized, the PHP has its own filesystem separate from the project
 * files. It's provided by [Emscripten and uses its FS library](https://emscripten.org/docs/api_reference/Filesystem-API.html).
 *
 * The API exposed to you via the PHP class is succinct and abstracts
 * await certain unintuitive parts of low-level FS interactions.
 *
 * Here's how to use it:
 *
 * ```js
 * // Recursively create a /var/www directory
 * php.mkdirTree('/var/www');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // false
 *
 * php.writeFile('/var/www/file.txt', 'Hello from the filesystem!');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // true
 *
 * console.log(php.readFile('/var/www/file.txt'));
 * // "Hello from the filesystem!
 *
 * // Delete the file:
 * php.unlink('/var/www/file.txt');
 * ```
 *
 * For more details consult the PHP class directly.
 *
 * **Data dependencies:**
 *
 * Using existing PHP packages by manually recreating them file-by-file would
 * be quite inconvenient. Fortunately, Emscripten provides a "data dependencies"
 * feature.
 *
 * Data dependencies consist of a `dependency.data` file and a `dependency.js` loader and
 * can be packaged with the [file_packager.py tool]( https://emscripten.org/docs/porting/files/packaging_files.html#packaging-using-the-file-packager-tool).
 * This project requires wrapping the Emscripten-generated `dependency.js` file in an ES
 * module as follows:
 *
 * 1. Prepend `export default function(emscriptenPHPModule) {'; `
 * 2. Prepend `export const dependencyFilename = '<DATA FILE NAME>'; `
 * 3. Prepend `export const dependenciesTotalSize = <DATA FILE SIZE>;`
 * 4. Append `}`
 *
 * Be sure to use the `--export-name="emscriptenPHPModule"` file_packager.py option.
 *
 * You want the final output to look as follows:
 *
 * ```js
 * export const dependenciesTotalSize = 5644199;
 * export const dependencyFilename = 'dependency.data';
 * export default function(emscriptenPHPModule) {
 *    // Emscripten-generated code:
 *    var Module = typeof emscriptenPHPModule !== 'undefined' ? emscriptenPHPModule : {};
 *    // ... the rest of it ...
 * }
 * ```
 *
 * Such a constructions enables loading the `dependency.js` as an ES Module using
 * `import("/dependency.js")`.
 *
 * Once it's ready, you can load PHP and your data dependencies as follows:
 *
 * ```js
 *  const [phpLoaderModule, wordPressLoaderModule] = await Promise.all([
 *    import("/php.js"),
 *    import("/wp.js")
 *  ]);
 *  const php = await startPHP(phpLoaderModule, "web", {}, [wordPressLoaderModule]);
 * ```
 *
 * @public
 * @param  phpLoaderModule         - The ESM-wrapped Emscripten module. Consult the Dockerfile for the build process.
 * @param  runtime                 - The current JavaScript environment. One of: NODE, WEB, or WEBWORKER.
 * @param  phpModuleArgs           - The Emscripten module arguments, see https://emscripten.org/docs/api_reference/module.html#affecting-execution.
 * @param  dataDependenciesModules - A list of the ESM-wrapped Emscripten data dependency modules.
 * @returns PHP instance.
 */
export async function startPHP(
	phpLoaderModule: any,
	runtime: JavascriptRuntime,
	phpModuleArgs: any = {},
	dataDependenciesModules: any[] = []
): Promise<PHP> {
	let resolvePhpReady, resolveDepsReady;
	const depsReady = new Promise((resolve) => {
		resolveDepsReady = resolve;
	});
	const phpReady = new Promise((resolve) => {
		resolvePhpReady = resolve;
	});

	const loadPHPRuntime = phpLoaderModule.default;
	const PHPRuntime = loadPHPRuntime(runtime, {
		onAbort(reason) {
			console.error('WASM aborted: ');
			console.error(reason);
		},
		...phpModuleArgs,
		noInitialRun: true,
		onRuntimeInitialized() {
			if (phpModuleArgs.onRuntimeInitialized) {
				phpModuleArgs.onRuntimeInitialized();
			}
			resolvePhpReady();
		},
		monitorRunDependencies(nbLeft) {
			if (nbLeft === 0) {
				delete PHPRuntime.monitorRunDependencies;
				resolveDepsReady();
			}
		},
	});
	for (const { default: loadDataModule } of dataDependenciesModules) {
		loadDataModule(PHPRuntime);
	}
	if (!dataDependenciesModules.length) {
		resolveDepsReady();
	}

	await depsReady;
	await phpReady;
	return new PHP(PHPRuntime);
}

/**
 * An environment-agnostic wrapper around the Emscripten PHP runtime
 * that abstracts the super low-level API and provides a more convenient
 * higher-level API.
 *
 * It exposes a minimal set of methods to run PHP scripts and to
 * interact with the PHP filesystem.
 *
 * @public
 * @see {startPHP} This class is not meant to be used directly. Use `startPHP` instead.
 */
export class PHP {
	#Runtime;
	#exitCode;

	/**
	 * Initializes a PHP runtime.
	 *
	 * @internal
	 * @param  PHPRuntime - PHP Runtime as initialized by startPHP.
	 */
	constructor(PHPRuntime: any) {
		this.#Runtime = PHPRuntime;

		this.mkdirTree('/usr/local/etc');
		// @TODO: make this customizable
		this.writeFile(
			'/usr/local/etc/php.ini',
			`[PHP]
error_reporting = E_ALL
display_errors = 1
html_errors = 1
display_startup_errors = On
session.save_path=/home/web_user
    `
		);
		this.#Runtime.ccall('php_wasm_init', null, [], []);
	}

	sapi() {
		this.#Runtime.ccall('wasm_set_query_string', null, [STR], ['a=b&c=d']);
		this.#Runtime.ccall(
			'wasm_set_request_body',
			null,
			[STR],
			[
				`

--12345
Content-Disposition: form-data; name="sometext"

some text that you wrote in your html form ...
--12345
Content-Disposition: form-data; name="name_of_post_request" filename="filename.xyz"

content of filename.xyz that you upload in your form with input[type=file]
--12345
Content-Disposition: form-data; name="image"; filename="picture_of_sunset.jpg"

content of picture_of_sunset.jpg ...
--12345--`,
			]
		);
		this.#Runtime.ccall(
			'wasm_set_path_translated',
			null,
			[STR],
			['/test/index.php']
		);
		this.#Runtime.ccall('wasm_set_request_uri', null, [STR], ['/index.php']);
		this.#Runtime.ccall('wasm_set_request_method', null, [STR], ['POST']);
		this.#Runtime.ccall(
			'wasm_set_content_type',
			null,
			[STR],
			// ['application/x-www-form-urlencoded']
			['multipart/form-data; boundary=12345']
		);
		this.#Runtime.ccall(
			'wasm_add_SERVER_entry',
			null,
			[STR, STR],
			['HTTP_X2_TEST', 'TEST2_PASSED..?!']
		);
		this.#Runtime.ccall(
			'wasm_add_SERVER_entry',
			null,
			[STR, STR],
			['HTTP_X99999999995_TEST', 'TEST5_PASSED9999991|2|3|4']
		);
		this.#Runtime.ccall(
			'wasm_set_php_code',
			null,
			[STR],
			[
				' echo "1"; print_r($_SERVER); print_r($_POST); print_r($_FILES); echo file_get_contents("php://input"); ',
			]
		);
		const num = this.#Runtime.ccall(
			'wasm_sapi_handle_request',
			NUM,
			[],
			[]
		);

		console.log({ num });
		console.log(this.getOutput().stderr);
		return new TextDecoder().decode(this.getOutput().stdout);
	}

	sapi2() {
		this.#Runtime.ccall('wasm_set_request_uri', null, [STR], ['/index.php']);
		this.#Runtime.ccall('wasm_set_request_method', null, [STR], ['GET']);
		this.#Runtime.ccall(
			'wasm_set_content_type',
			null,
			[STR],
			// ['application/x-www-form-urlencoded']
			['multipart/form-data; boundary=12345']
		);
		this.#Runtime.ccall(
			'wasm_add_SERVER_entry',
			null,
			[STR, STR],
			['HTTP_X2_TEST', 'TEST2_PASSED..?!']
		);
		this.#Runtime.ccall(
			'wasm_add_SERVER_entry',
			null,
			[STR, STR],
			['HTTP_X99999999995_TEST', 'TEST5_PASSED9999991|2|3|4']
		);
		this.#Runtime.ccall(
			'wasm_set_php_code',
			null,
			[STR],
			[
				' echo "1"; print_r($_SERVER); print_r($_POST); print_r($_FILES); echo file_get_contents("php://input"); ',
			]
		);
		const num = this.#Runtime.ccall(
			'wasm_sapi_handle_request',
			NUM,
			[],
			[]
		);

		console.log({ num });
		console.log(this.getOutput().stderr);
		return new TextDecoder().decode(this.getOutput().stdout);
	}

	initContext(requestBodyWithoutFiles = '') {
		this.#Runtime.ccall(
			'phpwasm_init_context',
			NUM,
			[STR],
			[requestBodyWithoutFiles]
		);
		this.run(`<?php
		$_SESSION = array();
		$_COOKIES = array();
		$_SERVER = array();
		error_reporting(E_ALL);
		$stdErr = fopen('php://stderr', 'w');
		set_error_handler(function(...$args) use($stdErr){
			fwrite($stdErr, '___after');
			fwrite($stdErr, print_r($args,1));
		});
		`);
	}

	/**
	 * Destroys the current PHP context.
	 * Any variables, functions, classes, etc. defined in the previous
	 * context will be lost. This methods needs to always be called after
	 * running PHP code, or else the next call to `run` will be contaminated
	 * with the previous context.
	 */
	destroyContext() {
		this.#Runtime.ccall('phpwasm_destroy_context', null, [], []);
	}

	getOutput(): PHPOutput {
		return {
			exitCode: this.#exitCode,
			stdout: this.readFileAsBuffer('/tmp/stdout'),
			stderr: this.readFileAsText('/tmp/stderr').split('\n'),
		};
	}

	populateArray(superglobal, data) {
		this.run(`<?php
			$data = (object) json_decode(<<<'DATA'
				${JSON.stringify(data)}
DATA
			, true);
			foreach($data as $key => $value) {
				${superglobal}[$key] = $value;
			}
			unset($data, $key, $value);
		`);
	}

	populateArrayFromRequestData(arrayName, requestData) {
		this.run(`<?php
			$request_data = (object) json_decode(<<<'DATA'
				${JSON.stringify(requestData)}
DATA
			, true);

			// $request_data keys could indicate nested arrays,
			// e.g. files[first]
			// We need to parse the entire requestData array
			// as a query string to get the data structure PHP expects.
			parse_str( http_build_query( $request_data ), $parsed_data );
			if(!isset(${arrayName})) {
				${arrayName} = [];
			}
			${arrayName} = array_merge_recursive(
				${arrayName},
				$parsed_data
			);
			unset($request_data, $parsed_data);
		`);
	}

	/**
	 * Runs a PHP script and outputs an object with three properties:
	 * stdout, stderr, and the exitCode.
	 *
	 * * `exitCode` – the exit code of the script. `0` is a success, while `1` and `2` indicate an error.
	 * * `stdout` – containing the output from `echo`, `print`, inline HTML etc.
	 * * `stderr` – containing all the errors are logged. It can also be written
	 *              to explicitly:
	 *
	 * @example
	 * ```js
	 * const output = php.run('<?php echo "Hello world!";');
	 * console.log(output.stdout); // "Hello world!"
	 * ```
	 *
	 * @example
	 * ```js
	 * console.log(php.run(`<?php
	 *  $fp = fopen('php://stderr', 'w');
	 *  fwrite($fp, "Hello, world!");
	 * `));
	 * // {"exitCode":0,"stdout":"","stderr":["Hello, world!"]}
	 * ```
	 *
	 * @param  code - The PHP code to run.
	 */
	run(code: string) {
		console.log({ code });
		this.#exitCode = this.#Runtime.ccall(
			'phpwasm_run',
			NUM,
			[STR],
			[`?>${code}`]
		);
	}

	/**
	 * Recursively creates a directory with the given path in the PHP filesystem.
	 * For example, if the path is `/root/php/data`, and `/root` already exists,
	 * it will create the directories `/root/php` and `/root/php/data`.
	 *
	 * @param  path - The directory path to create.
	 */
	mkdirTree(path: string) {
		this.#Runtime.FS.mkdirTree(path);
	}

	/**
	 * Reads a file from the PHP filesystem and returns it as a string.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsText(path: string): string {
		return new TextDecoder().decode(this.readFileAsBuffer(path));
	}

	/**
	 * Reads a file from the PHP filesystem and returns it as an array buffer.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to read.
	 * @returns The file contents.
	 */
	readFileAsBuffer(path: string): Uint8Array {
		return this.#Runtime.FS.readFile(path);
	}

	/**
	 * Overwrites data in a file in the PHP filesystem.
	 * Creates a new file if one doesn't exist yet.
	 *
	 * @param  path - The file path to write to.
	 * @param  data - The data to write to the file.
	 */
	writeFile(path: string, data: string | Uint8Array) {
		this.#Runtime.FS.writeFile(path, data);
	}

	/**
	 * Removes a file from the PHP filesystem.
	 *
	 * @throws {@link ErrnoError} – If the file doesn't exist.
	 * @param  path - The file path to remove.
	 */
	unlink(path: string) {
		this.#Runtime.FS.unlink(path);
	}

	/**
	 * Lists the files and directories in the given directory.
	 *
	 * @param  path - The directory path to list.
	 * @returns The list of files and directories in the given directory.
	 */
	listFiles(path: string): string[] {
		if (!this.fileExists(path)) {
			return [];
		}
		try {
			return this.#Runtime.FS.readdir(path).filter(
				(name) => name !== '.' && name !== '..'
			);
		} catch (e) {
			console.error(e, { path });
			return [];
		}
	}

	/**
	 * Checks if a directory exists in the PHP filesystem.
	 *
	 * @param  path – The path to check.
	 * @returns True if the path is a directory, false otherwise.
	 */
	isDir(path: string): boolean {
		if (!this.fileExists(path)) {
			return false;
		}
		return this.#Runtime.FS.isDir(
			this.#Runtime.FS.lookupPath(path).node.mode
		);
	}

	/**
	 * Checks if a file (or a directory) exists in the PHP filesystem.
	 *
	 * @param  path - The file path to check.
	 * @returns True if the file exists, false otherwise.
	 */
	fileExists(path: string): boolean {
		try {
			this.#Runtime.FS.lookupPath(path);
			return true;
		} catch (e) {
			return false;
		}
	}

	/**
	 * Allocates an internal HashTable to keep track of the legitimate uploads.
	 *
	 * Supporting file uploads via WebAssembly is a bit tricky.
	 * Functions like `is_uploaded_file` or `move_uploaded_file` fail to work
	 * with those $_FILES entries that are not in an internal hash table. This
	 * is a security feature, see this exceprt from the `is_uploaded_file` documentation:
	 *
	 * > is_uploaded_file
	 * >
	 * > Returns true if the file named by filename was uploaded via HTTP POST. This is
	 * > useful to help ensure that a malicious user hasn't tried to trick the script into
	 * > working on files upon which it should not be working--for instance, /etc/passwd.
	 * >
	 * > This sort of check is especially important if there is any chance that anything
	 * > done with uploaded files could reveal their contents to the user, or even to other
	 * > users on the same system.
	 * >
	 * > For proper working, the function is_uploaded_file() needs an argument like
	 * > $_FILES['userfile']['tmp_name'], - the name of the uploaded file on the client's
	 * > machine $_FILES['userfile']['name'] does not work.
	 *
	 * This PHP.wasm implementation doesn't run any PHP request machinery, so PHP never has
	 * a chance to note which files were actually uploaded. In practice, `is_uploaded_file()`
	 * always returns false.
	 *
	 * `initUploadedFilesHash()`, `registerUploadedFile()`, and `destroyUploadedFilesHash()`
	 * are a workaround for this problem. They allow you to manually register uploaded
	 * files in the internal hash table, so that PHP functions like `move_uploaded_file()`
	 * can recognize them.
	 *
	 * Usage:
	 *
	 * ```js
	 * // Create an uploaded file in the PHP filesystem.
	 * php.writeFile(
	 *    '/tmp/test.txt',
	 *    'I am an uploaded file!'
	 * );
	 *
	 * // Allocate the internal hash table.
	 * php.initUploadedFilesHash();
	 *
	 * // Register the uploaded file.
	 * php.registerUploadedFile('/tmp/test.txt');
	 *
	 * // Run PHP code that uses the uploaded file.
	 * php.run(`<?php
	 *  _FILES[key] = {
	 *      name: value.name,
	 *      type: value.type,
	 *      tmp_name: tmpPath,
	 *      error: 0,
	 *      size: value.size,
	 *  };
	 *  var_dump(is_uploaded_file($_FILES["file1"]["tmp_name"]));
	 *  // true
	 * `);
	 *
	 * // Destroy the internal hash table to free the memory.
	 * php.destroyUploadedFilesHash();
	 * ```
	 */
	initUploadedFilesHash() {
		this.#Runtime.ccall('phpwasm_init_uploaded_files_hash', null, [], []);
	}

	async preUploadFiles(files: Record<string, File>): Promise<string[]> {
		const uploadedFiles: string[] = [];
		for (const [key, file] of Object.entries(files)) {
			const tmpPath = this.preUploadFile(
				key,
				file.name,
				file.type,
				file.size,
				new Uint8Array(await file.arrayBuffer())
			);
			uploadedFiles.push(tmpPath);
		}
		return uploadedFiles;
	}

	/**
	 * Registers an uploaded file in the internal hash table.
	 *
	 * @see initUploadedFilesHash()
	 * @param  key
	 * @param  name
	 * @param  type
	 * @param  size
	 * @param  data
	 * @return The temporary path of the uploaded file.
	 */
	preUploadFile(
		key: string,
		name: string,
		type: string,
		size: number,
		data: Uint8Array
	): string {
		const tmpName = Math.random().toFixed(20);
		const tmpPath = `/tmp/${tmpName}`;

		this.registerUploadedFile(tmpPath);
		this.writeFile(tmpPath, data);
		this.populateArrayFromRequestData('$_FILES', {
			[key]: { name, type, tmp_name: tmpPath, error: 0, size },
		});
		return tmpPath;
	}

	/**
	 * Registers an uploaded file in the internal hash table.
	 *
	 * @see initUploadedFilesHash()
	 * @param  tmpPath - The temporary path of the uploaded file.
	 */
	registerUploadedFile(tmpPath: string) {
		this.#Runtime.ccall(
			'phpwasm_register_uploaded_file',
			null,
			[STR],
			[tmpPath]
		);
	}

	/**
	 * Destroys the internal hash table to free the memory.
	 *
	 * @see initUploadedFilesHash()
	 */
	destroyUploadedFilesHash() {
		this.#Runtime.ccall(
			'phpwasm_destroy_uploaded_files_hash',
			null,
			[],
			[]
		);
	}
}

/**
 * Output of the PHP.wasm runtime.
 */
export interface PHPOutput {
	/** Exit code of the PHP process. 0 means success, 1 and 2 mean error. */
	exitCode: number;

	/** Stdout data */
	stdout: ArrayBuffer;

	/** Stderr lines */
	stderr: string[];
}

/**
 * Emscripten's filesystem-related Exception.
 *
 * @see https://emscripten.org/docs/api_reference/Filesystem-API.html
 * @see https://github.com/emscripten-core/emscripten/blob/main/system/lib/libc/musl/arch/emscripten/bits/errno.h
 */
export interface ErrnoError extends Error {}

export interface PHPRunOptions {
	/**
	 * Raw POST data to populate php://input.
	 *
	 * This should *not* contain any uploaded file information.
	 *
	 * Files are handled separately via the uploadedFiles option.
	 */
	requestBodyWithoutFiles?: string;

	/**
	 * Files to populate $_FILES.
	 */
	uploadedFiles?: Record<string, File>;
}
