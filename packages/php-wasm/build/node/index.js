import { TextEncoder, TextDecoder as TextDecoder$1 } from 'util';

const STR = 'string';
const NUM = 'number';
const loadedRuntimes = [];
/**
 * Loads the PHP runtime with the given arguments and data dependencies.
 *
 * This function handles the entire PHP initialization pipeline. In particular, it:
 *
 * * Instantiates the Emscripten PHP module
 * * Wires it together with the data dependencies and loads them
 * * Ensures is all happens in a correct order
 * * Waits until the entire loading sequence is finished
 *
 * Basic usage:
 *
 * ```js
 *  const phpLoaderModule = await import("/php.js");
 *  const php = await startPHP(phpLoaderModule, "web");
 *  console.log(php.run(`<?php echo "Hello, world!"; `));
 *  // { stdout: ArrayBuffer containing the string "Hello, world!", stderr: [''], exitCode: 0 }
 * ```
 *
 * **The `/php.js` module:**
 *
 * In the basic usage example, `php.js` is **not** a vanilla Emscripten module. Instead,
 * it's an ESM module that wraps the regular Emscripten output and adds some
 * extra functionality. It's generated by the Dockerfile shipped with this repo.
 * Here's the API it provides:
 *
 * ```js
 * // php.wasm size in bytes:
 * export const dependenciesTotalSize = 5644199;
 *
 * // php.wasm filename:
 * export const dependencyFilename = 'php.wasm';
 *
 * // Run Emscripten's generated module:
 * export default function(jsEnv, emscriptenModuleArgs) {}
 * ```
 *
 * **PHP Filesystem:**
 *
 * Once initialized, the PHP has its own filesystem separate from the project
 * files. It's provided by [Emscripten and uses its FS library](https://emscripten.org/docs/api_reference/Filesystem-API.html).
 *
 * The API exposed to you via the PHP class is succinct and abstracts
 * await certain unintuitive parts of low-level FS interactions.
 *
 * Here's how to use it:
 *
 * ```js
 * // Recursively create a /var/www directory
 * php.mkdirTree('/var/www');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // false
 *
 * php.writeFile('/var/www/file.txt', 'Hello from the filesystem!');
 *
 * console.log(php.fileExists('/var/www/file.txt'));
 * // true
 *
 * console.log(php.readFile('/var/www/file.txt'));
 * // "Hello from the filesystem!
 *
 * // Delete the file:
 * php.unlink('/var/www/file.txt');
 * ```
 *
 * For more details consult the PHP class directly.
 *
 * **Data dependencies:**
 *
 * Using existing PHP packages by manually recreating them file-by-file would
 * be quite inconvenient. Fortunately, Emscripten provides a "data dependencies"
 * feature.
 *
 * Data dependencies consist of a `dependency.data` file and a `dependency.js` loader and
 * can be packaged with the [file_packager.py tool]( https://emscripten.org/docs/porting/files/packaging_files.html#packaging-using-the-file-packager-tool).
 * This project requires wrapping the Emscripten-generated `dependency.js` file in an ES
 * module as follows:
 *
 * 1. Prepend `export default function(emscriptenPHPModule) {'; `
 * 2. Prepend `export const dependencyFilename = '<DATA FILE NAME>'; `
 * 3. Prepend `export const dependenciesTotalSize = <DATA FILE SIZE>;`
 * 4. Append `}`
 *
 * Be sure to use the `--export-name="emscriptenPHPModule"` file_packager.py option.
 *
 * You want the final output to look as follows:
 *
 * ```js
 * export const dependenciesTotalSize = 5644199;
 * export const dependencyFilename = 'dependency.data';
 * export default function(emscriptenPHPModule) {
 *    // Emscripten-generated code:
 *    var Module = typeof emscriptenPHPModule !== 'undefined' ? emscriptenPHPModule : {};
 *    // ... the rest of it ...
 * }
 * ```
 *
 * Such a constructions enables loading the `dependency.js` as an ES Module using
 * `import("/dependency.js")`.
 *
 * Once it's ready, you can load PHP and your data dependencies as follows:
 *
 * ```js
 *  const [phpLoaderModule, wordPressLoaderModule] = await Promise.all([
 *    import("/php.js"),
 *    import("/wp.js")
 *  ]);
 *  const php = await startPHP(phpLoaderModule, "web", {}, [wordPressLoaderModule]);
 * ```
 *
 * @public
 * @param  phpLoaderModule         - The ESM-wrapped Emscripten module. Consult the Dockerfile for the build process.
 * @param  runtime                 - The current JavaScript environment. One of: NODE, WEB, or WEBWORKER.
 * @param  phpModuleArgs           - The Emscripten module arguments, see https://emscripten.org/docs/api_reference/module.html#affecting-execution.
 * @param  dataDependenciesModules - A list of the ESM-wrapped Emscripten data dependency modules.
 * @returns Loaded runtime id.
 */
async function loadPHPRuntime(phpLoaderModule, phpModuleArgs = {}, dataDependenciesModules = []) {
    let resolvePhpReady, resolveDepsReady;
    const depsReady = new Promise((resolve) => {
        resolveDepsReady = resolve;
    });
    const phpReady = new Promise((resolve) => {
        resolvePhpReady = resolve;
    });
    const PHPRuntime = phpLoaderModule.default(currentJsRuntime, {
        onAbort(reason) {
            console.error('WASM aborted: ');
            console.error(reason);
        },
        ENV: {},
        // Emscripten sometimes prepends a '/' to the path, which
        // breaks vite dev mode. An identity `locateFile` function
        // fixes it.
        locateFile: (path) => path,
        ...phpModuleArgs,
        noInitialRun: true,
        onRuntimeInitialized() {
            if (phpModuleArgs.onRuntimeInitialized) {
                phpModuleArgs.onRuntimeInitialized();
            }
            resolvePhpReady();
        },
        monitorRunDependencies(nbLeft) {
            if (nbLeft === 0) {
                delete PHPRuntime.monitorRunDependencies;
                resolveDepsReady();
            }
        },
    });
    for (const { default: loadDataModule } of dataDependenciesModules) {
        loadDataModule(PHPRuntime);
    }
    if (!dataDependenciesModules.length) {
        resolveDepsReady();
    }
    await depsReady;
    await phpReady;
    loadedRuntimes.push(PHPRuntime);
    return loadedRuntimes.length - 1;
}
const currentJsRuntime = (function () {
    if (typeof window !== 'undefined') {
        return 'WEB';
    }
    else if (typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope) {
        return 'WORKER';
    }
    else {
        return 'NODE';
    }
})();
/**
 * An environment-agnostic wrapper around the Emscripten PHP runtime
 * that abstracts the super low-level API and provides a more convenient
 * higher-level API.
 *
 * It exposes a minimal set of methods to run PHP scripts and to
 * interact with the PHP filesystem.
 *
 * @public
 * @see {startPHP} This class is not meant to be used directly. Use `startPHP` instead.
 */
class PHP {
    #Runtime;
    #phpIniOverrides = [];
    #webSapiInitialized = false;
    /**
     * Initializes a PHP runtime.
     *
     * @internal
     * @param  PHPRuntime - Optional. PHP Runtime ID as initialized by loadPHPRuntime.
     */
    constructor(PHPRuntimeId) {
        if (PHPRuntimeId !== undefined) {
            this.initializeRuntime(PHPRuntimeId);
        }
    }
    initializeRuntime(runtimeId) {
        if (this.#Runtime) {
            throw new Error('PHP runtime already initialized.');
        }
        if (!loadedRuntimes[runtimeId]) {
            throw new Error('Invalid PHP runtime id.');
        }
        this.#Runtime = loadedRuntimes[runtimeId];
    }
    setPhpIniPath(path) {
        if (this.#webSapiInitialized) {
            throw new Error('Cannot set PHP ini path after calling run().');
        }
        this.#Runtime.ccall('wasm_set_phpini_path', null, ['string'], [path]);
    }
    setPhpIniEntry(key, value) {
        if (this.#webSapiInitialized) {
            throw new Error('Cannot set PHP ini entries after calling run().');
        }
        this.#phpIniOverrides.push([key, value]);
    }
    run(request = {}) {
        if (!this.#webSapiInitialized) {
            this.#initWebRuntime();
            this.#webSapiInitialized = true;
        }
        this.#setScriptPath(request.scriptPath || '');
        this.#setRelativeRequestUri(request.relativeUri || '');
        this.#setRequestMethod(request.method || 'GET');
        const { host, ...headers } = {
            host: 'example.com:443',
            ...normalizeHeaders(request.headers || {}),
        };
        this.#setRequestHostAndProtocol(host, request.protocol || 'http');
        this.#setRequestHeaders(headers);
        if (request.body) {
            this.#setRequestBody(request.body);
        }
        if (request.fileInfos) {
            for (const file of request.fileInfos) {
                this.#addUploadedFile(file);
            }
        }
        if (request.code) {
            this.#setPHPCode(' ?>' + request.code);
        }
        return this.#handleRequest();
    }
    #initWebRuntime() {
        if (this.#phpIniOverrides.length > 0) {
            const overridesAsIni = this.#phpIniOverrides
                .map(([key, value]) => `${key}=${value}`)
                .join('\n');
            this.#Runtime.ccall('wasm_set_phpini_entries', null, [STR], [overridesAsIni]);
        }
        this.#Runtime.ccall('php_wasm_init', null, [], []);
    }
    cli(argv) {
        for (const arg of argv) {
            this.#Runtime.ccall('wasm_add_cli_arg', null, [STR], [arg]);
        }
        return this.#Runtime.ccall('run_cli', null, [], [], { async: true });
    }
    #getResponseHeaders() {
        const headersFilePath = '/tmp/headers.json';
        if (!this.fileExists(headersFilePath)) {
            throw new Error('SAPI Error: Could not find response headers file.');
        }
        const headersData = JSON.parse(this.readFileAsText(headersFilePath));
        const headers = {};
        for (const line of headersData.headers) {
            if (!line.includes(': ')) {
                continue;
            }
            const colonIndex = line.indexOf(': ');
            const headerName = line.substring(0, colonIndex).toLowerCase();
            const headerValue = line.substring(colonIndex + 2);
            if (!(headerName in headers)) {
                headers[headerName] = [];
            }
            headers[headerName].push(headerValue);
        }
        return {
            headers,
            httpStatusCode: headersData.status,
        };
    }
    #setRelativeRequestUri(uri) {
        this.#Runtime.ccall('wasm_set_request_uri', null, [STR], [uri]);
        if (uri.includes('?')) {
            const queryString = uri.substring(uri.indexOf('?') + 1);
            this.#Runtime.ccall('wasm_set_query_string', null, [STR], [queryString]);
        }
    }
    #setRequestHostAndProtocol(host, protocol) {
        this.#Runtime.ccall('wasm_set_request_host', null, [STR], [host]);
        let port;
        try {
            port = parseInt(new URL(host).port, 10);
        }
        catch (e) { }
        if (!port || isNaN(port) || port === 80) {
            port = protocol === 'https' ? 443 : 80;
        }
        this.#Runtime.ccall('wasm_set_request_port', null, [NUM], [port]);
        if (protocol === 'https' || (!protocol && port === 443)) {
            this.addServerGlobalEntry('HTTPS', 'on');
        }
    }
    #setRequestMethod(method) {
        this.#Runtime.ccall('wasm_set_request_method', null, [STR], [method]);
    }
    setSkipShebang(shouldSkip) {
        this.#Runtime.ccall('wasm_set_skip_shebang', null, [NUM], [shouldSkip ? 1 : 0]);
    }
    #setRequestHeaders(headers) {
        if (headers.cookie) {
            this.#Runtime.ccall('wasm_set_cookies', null, [STR], [headers.cookie]);
        }
        if (headers['content-type']) {
            this.#Runtime.ccall('wasm_set_content_type', null, [STR], [headers['content-type']]);
        }
        if (headers['content-length']) {
            this.#Runtime.ccall('wasm_set_content_length', null, [NUM], [parseInt(headers['content-length'], 10)]);
        }
        for (const name in headers) {
            this.addServerGlobalEntry(`HTTP_${name.toUpperCase().replace(/-/g, '_')}`, headers[name]);
        }
    }
    #setRequestBody(body) {
        this.#Runtime.ccall('wasm_set_request_body', null, [STR], [body]);
        this.#Runtime.ccall('wasm_set_content_length', null, [NUM], [body.length]);
    }
    #setScriptPath(path) {
        this.#Runtime.ccall('wasm_set_path_translated', null, [STR], [path]);
    }
    addServerGlobalEntry(key, value) {
        this.#Runtime.ccall('wasm_add_SERVER_entry', null, [STR, STR], [key, value]);
    }
    /**
     * Adds file information to $_FILES superglobal in PHP.
     *
     * In particular:
     * * Creates the file data in the filesystem
     * * Registers the file details in PHP
     *
     * @param  fileInfo - File details
     */
    #addUploadedFile(fileInfo) {
        const { key, name, type, data } = fileInfo;
        const tmpPath = `/tmp/${Math.random().toFixed(20)}`;
        this.writeFile(tmpPath, data);
        const error = 0;
        this.#Runtime.ccall('wasm_add_uploaded_file', null, [STR, STR, STR, STR, NUM, NUM], [key, name, type, tmpPath, error, data.byteLength]);
    }
    #setPHPCode(code) {
        this.#Runtime.ccall('wasm_set_php_code', null, [STR], [code]);
    }
    #handleRequest() {
        const exitCode = this.#Runtime.ccall('wasm_sapi_handle_request', NUM, [], []);
        return {
            exitCode,
            body: this.readFileAsBuffer('/tmp/stdout'),
            errors: this.readFileAsText('/tmp/stderr'),
            ...this.#getResponseHeaders(),
        };
    }
    mkdirTree(path) {
        this.#Runtime.FS.mkdirTree(path);
    }
    readFileAsText(path) {
        return new TextDecoder().decode(this.readFileAsBuffer(path));
    }
    readFileAsBuffer(path) {
        return this.#Runtime.FS.readFile(path);
    }
    writeFile(path, data) {
        this.#Runtime.FS.writeFile(path, data);
    }
    unlink(path) {
        this.#Runtime.FS.unlink(path);
    }
    listFiles(path) {
        if (!this.fileExists(path)) {
            return [];
        }
        try {
            return this.#Runtime.FS.readdir(path).filter((name) => name !== '.' && name !== '..');
        }
        catch (e) {
            console.error(e, { path });
            return [];
        }
    }
    isDir(path) {
        if (!this.fileExists(path)) {
            return false;
        }
        return this.#Runtime.FS.isDir(this.#Runtime.FS.lookupPath(path).node.mode);
    }
    fileExists(path) {
        try {
            this.#Runtime.FS.lookupPath(path);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    mount(settings, path) {
        this.#Runtime.FS.mount(this.#Runtime.FS.filesystems.NODEFS, settings, path);
    }
}
function normalizeHeaders(headers) {
    const normalized = {};
    for (const key in headers) {
        normalized[key.toLowerCase()] = headers[key];
    }
    return normalized;
}

/**
 * A wrapper file that polyfills global APIs for Node.js
 * and re-exports everything from the main PHP module.
 */
global.TextEncoder = TextEncoder;
global.TextDecoder = TextDecoder$1;
async function getPHPLoaderModule(version = '8.2') {
    switch (version) {
        case '8.2':
            // @ts-ignore
            return await import('./php-8.2.node-b1e27e6c.js');
        case '8.1':
            // @ts-ignore
            return await import('./php-8.1.node-2b8077c0.js');
        case '8.0':
            // @ts-ignore
            return await import('./php-8.0.node-882846ce.js');
        case '7.4':
            // @ts-ignore
            return await import('./php-7.4.node-bc626a67.js');
        case '7.3':
            // @ts-ignore
            return await import('./php-7.3.node-c9b8bc4f.js');
        case '7.2':
            // @ts-ignore
            return await import('./php-7.2.node-be724318.js');
        case '7.1':
            // @ts-ignore
            return await import('./php-7.1.node-7801f09d.js');
        case '7.0':
            // @ts-ignore
            return await import('./php-7.0.node-52042e32.js');
        case '5.6':
            // @ts-ignore
            return await import('./php-5.6.node-bc740b12.js');
    }
    throw new Error(`Unsupported PHP version ${version}`);
}

export { PHP, getPHPLoaderModule, loadPHPRuntime };
